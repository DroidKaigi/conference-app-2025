# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

This is the **DroidKaigi 2025 conference application** - a Kotlin Multiplatform project supporting Android, iOS, and Desktop platforms.

# Requirements

- **Android Studio**: Narwhal or higher (latest version recommended)
- **JVM**: 17 or higher (required by Gradle 9.0.0)

# Commands

## Development Commands
- `./gradlew spotlessCheck`: Lint check - validates code formatting and style
- `./gradlew spotlessApply`: Format code - applies consistent formatting across codebase
- `./gradlew testDebugUnitTest`: Run unit tests for debug build variant

## Platform-Specific Build Commands
- `./gradlew :app-android:assembleDebug`: Build Android debug APK
- `./gradlew :app-android:assembleDevDebug`: Build Android dev variant (development API)
- `./gradlew :app-android:assembleProdDebug`: Build Android prod variant (production API)
- `./gradlew :app-desktop:run`: Run desktop application
- iOS builds are handled through Xcode project in `app-ios/` directory

## Testing Commands
- `./gradlew check`: Run all checks including tests and lint
- `./gradlew test`: Run all tests across platforms
- `./gradlew testReleaseUnitTest`: Run unit tests for release build variant
- `./gradlew recordRoborazziDebug`: Record screenshot tests (UI verification)
- `./gradlew verifyRoborazziDebug`: Verify screenshot tests
- `./gradlew compareRoborazziDebug`: Compare Roborazzi screenshots for debug variant
- `./gradlew compareRoborazziJvm`: Compare Roborazzi screenshots for JVM platform
- UI tests use Roborazzi for screenshot testing with multiplatform support

## Code Generation
- `./gradlew kspCommonMainKotlinMetadata`: Generate KSP code (Metro dependency injection, context retention functions)
- KSP generates `rememberXXXScreenContextRetained()` functions for configuration change persistence

# Architecture Overview

This is a Kotlin Multiplatform (KMP) conference application supporting Android, iOS, and Desktop platforms with sophisticated architecture patterns:

## Core Architecture Components

### Dependency Injection with Metro
- Uses compile-time safe dependency injection via [Metro](https://github.com/ZacSweers/metro)
- Each screen receives dependencies through `ScreenContext` as context parameters
- Dependencies are resolved at compile time, preventing runtime errors
- Example: `TimetableScreenContext` provides all dependencies needed for timetable functionality

### Data Management with Soil
- Replaces traditional repository pattern with [Soil](https://github.com/soil-kt/soil) for composable-first data fetching
- Uses `QueryKey` and `SubscriptionKey` for server/database state management
- Runtime caching handled automatically by Soil's `SwrClient`
- `SoilDataBoundary` separates data fetching logic from UI logic

### Screen Structure Pattern
- Entry point: `XXXScreenRoot` Composable functions
- Data boundary: `SoilDataBoundary` ensures all required data is available before rendering UI
- Presenters: Handle UI events and construct UI state as Composable functions
- Context parameters provide semantic meaning and scope restriction

### Navigation
- **Android/JVM**: Uses Navigation3 library with `NavKey` and `NavEntry` pattern
- **iOS**: Uses navigation-compose library due to Navigation3 not being available
- Screens defined as serializable `NavKey` objects for type-safe navigation
- `rememberXXXScreenContextRetained()` functions generated by KSP for configuration change persistence

## Module Structure

### Apps
- `app-android`: Android application module
- `app-desktop`: Desktop (JVM) application module  
- `app-ios`: iOS application with Xcode project
- `app-shared`: Shared application code and navigation logic

### Core Modules
- `core:common`: Common utilities and base classes
- `core:model`: Data models and domain entities
- `core:data`: Data layer with API clients and caching
- `core:droidkaigiui`: UI components and theming
- `core:designsystem`: Design system components
- `core:testing`: Testing infrastructure and utilities

### Features
- `feature:sessions`: Timetable, search, and session detail screens
- `feature:contributors`: Contributors listing
- `feature:sponsors`: Sponsors information
- `feature:eventmap`: Event venue map
- `feature:about`: About screen
- `feature:settings`: Application settings
- `feature:favorites`: Bookmarked sessions
- `feature:staff`: Staff information
- `feature:profile`: User profile management

## Testing Strategy

### Multiplatform UI Testing
- BDD-style tests using `describe`/`itShould` pattern for readability
- Tests shared across Android, JVM, and iOS using expect/actual mechanism
- Robot pattern for UI interactions and verifications
- Test-specific dependency graphs created with Metro for isolation
- Roborazzi used for screenshot testing across all platforms

### Test Structure Example
```kotlin
@RunWith(UiTestRunner::class)
class TimetableScreenTest {
    val testAppGraph = createTimetableScreenTestGraph()
    
    @ComposeTest
    fun runTest() {
        describedBehaviors.forEach { behavior ->
            val robot = testAppGraph.timetableScreenRobotProvider()
            runComposeUiTest { behavior.execute(robot) }
        }
    }
}
```

## iOS Integration Approaches

The project demonstrates multiple KMP integration strategies on iOS:

1. **Repository Access**: Expose repository classes to iOS with Molecule converting Compose state to Flows for SwiftUI
2. **Full Compose Multiplatform**: Complete `KaigiApp` runs via `ComposeUIViewController`
3. **KMP Presenter Integration**: KMP presenters provide UI state to native SwiftUI views
4. **Partial CMP Integration**: Individual screens use Compose UI while maintaining SwiftUI for others

## Key Technologies

- **UI**: Jetpack Compose with Compose Multiplatform
- **DI**: Metro for compile-time dependency injection
- **Data**: Soil for composable data fetching, Ktor for networking
- **Testing**: Roborazzi for screenshot testing, expect/actual for multiplatform tests
- **Navigation**: Navigation3 (Android/JVM), navigation-compose (iOS)
- **Build**: Gradle with Kotlin DSL and custom conventions

# Development Conventions

## File Patterns
- **Screen entry points**: `XXXScreenRoot.kt` (e.g., `TimetableScreenRoot.kt`)
- **Presenters**: `xxxScreenPresenter()` functions (e.g., `timetableScreenPresenter()`)
- **Context retention**: `rememberXXXScreenContextRetained()` (KSP-generated)
- **Screen contexts**: `XXXScreenContext` interfaces with Metro annotations
- **Test robots**: `XXXScreenRobot` classes in `core:testing`

## Context Parameters Pattern
All screen composables use context parameters for dependency injection:
```kotlin
context(screenContext: TimetableScreenContext)
@Composable
fun TimetableScreenRoot(...)
```

## Data Fetching Pattern
Use `SoilDataBoundary` to separate data fetching from UI logic:
```kotlin
SoilDataBoundary(
    state1 = rememberQuery(screenContext.queryKey),
    fallback = { LoadingIndicator() },
) { data ->
    // UI with guaranteed data availability
}
```

# Important Development Notes

## Network Flavors
- **dev**: Uses development API (`USE_PRODUCTION_API = false`), app ID suffix `.dev`
- **prod**: Uses production API (`USE_PRODUCTION_API = true`)

## KSP Code Generation
- KSP generates Metro dependency injection code and context retention functions
- If you see "unresolved reference" errors for `rememberXXXScreenContextRetained()`, run KSP generation
- Generated files are in `build/generated/ksp/` directories

## Testing Strategy
- BDD-style tests using `describe`/`itShould` pattern
- Robot pattern for UI interactions (`XXXScreenRobot` classes)
- Screenshot testing with Roborazzi across all platforms
- Test dependency graphs created with Metro for isolation

## Common Issues
- **Build failures**: Run `./gradlew clean` then rebuild
- **KSP errors**: Run `./gradlew kspCommonMainKotlinMetadata` to regenerate code
- **Context parameter errors**: Ensure proper `context(screenContext: XXXScreenContext)` usage
- **Soil data errors**: Wrap UI in `SoilDataBoundary` for proper data handling

# Commit Guidelines

- Only commit when:
    - ALL tests are passing
    - ALL compiler/linter warnings have been resolved
    - Commit messages clearly state whether the commit contains structural or behavioral changes
- Use conventional commit format for commit messages
- Run `./gradlew spotlessApply` before committing to ensure consistent formatting

# PR Planning & Review Standards

## Testing Requirements by Change Complexity
- **Simple fixes** (URL updates, minor tweaks): Existing tests must pass
- **UI changes**: Screenshot tests with Roborazzi required across platforms
- **Cross-platform features**: Test on Android, iOS, and JVM
- **Large features**: Comprehensive test coverage essential (praised as "thorough tests were really helpful")

## Platform-Specific Considerations for Planning
- **iOS changes**: Expect 7-9 review iterations for complex features, thorough technical discussions
- **JVM/Desktop**: Focus on window sizing, navigation behavior, crash prevention
- **Android**: Ensure Material Design compliance, keyboard handling, theme consistency

## Review Expectations by Scope
- **Simple changes**: 1-2 quick LGTM approvals typical
- **Medium features**: 2-3 review cycles expected  
- **Complex features**: Multiple detailed review rounds normal and expected

## What Reviewers Check Most Carefully
- **User Experience Consistency**: Haptic feedback patterns, visual theme alignment, navigation behavior
- **Architectural Adherence**: Following Metro DI, Soil data patterns, established conventions
- **Platform Guidelines**: iOS/Android/Desktop best practices compliance
- **No Regressions**: Existing functionality must remain intact
- **Performance Impact**: Especially for UI components and timeline features

# Important Reminders

- **Do what has been asked; nothing more, nothing less**
- **ALWAYS prefer editing existing files over creating new ones**
- **NEVER proactively create documentation files unless explicitly requested**
- Only create files when absolutely necessary for achieving the goal
